---
title: '数据查询优化的方法[转]'
tags:
  - 优化
id: 844
categories:
  - IT
abbrlink: 9f43058b
date: 2005-07-16 11:43:00
---

**1.mmf用IN来替换OR **
下面的查询可以被更有效率的语句替换: 
低效: 
SELECT field1, field1 FROM LOCATION 
WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30 

高效 
SELECT field1, field1 FROM LOCATION 
WHERE LOC_IN IN (10,20,30) 

**2.mmf连接多个扫描** 
如果你对一个列和一组有限的值进行比较, 优化器可能执行多次扫描并对结果进行合并连接. 
举例: 
SELECT * FROM LODGING 
WHERE MANAGER IN (‘BILL GATES’,’KEN MULLER’); 

优化器可能将它转换成以下形式 
SELECT * FROM LODGING 
WHERE MANAGER = ‘BILL GATES’ 
OR MANAGER = ’KEN MULLER’; 

**3.mmf优化GROUP BY **
提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉.下面两个查询返回相同结果但第二个明显就快了许多. 
低效: 
SELECT JOB , AVG(SAL) FROM EMP 
GROUP JOB HAVING JOB = ‘PRESIDENT’OR JOB = ‘MANAGER’ 
高效: 
SELECT JOB , AVG(SAL) FROM EMP 
WHERE JOB = ‘PRESIDENT’OR JOB = ‘MANAGER’ 
GROUP JOB 

**4.mmf用&gt;=替代&gt; **
如果DEPTNO上有一个索引, 
高效: 
SELECT * 
FROM EMP 
WHERE DEPTNO &gt;=4 

低效: 
SELECT * 
FROM EMP 
WHERE DEPTNO &gt;3 

**5.mmf用表连接替换EXISTS **
通常来说 , 采用表连接的方式比EXISTS更有效率 
SELECT ENAME 
FROM EMP E 
WHERE EXISTS (SELECT ‘X’ 
FROM DEPT 
WHERE DEPT_NO = E.DEPT_NO 
AND DEPT_CAT = ‘A’); 

(更高效) 
SELECT ENAME 
FROM DEPT D,EMP E 
WHERE E.DEPT_NO = D.DEPT_NO 
AND DEPT_CAT = ‘A’ ;

**6.mmf用EXISTS替换DISTINCT** 
当提交一个包含一对多表信息(比如部门表和雇员表)的查询时,避免在SELECT子句中使用DISTINCT. 一般可以考虑用EXIST替换 
低效: SELECT...... 
低效: 
SELECT DISTINCT DEPT_NO,DEPT_NAME 
FROM DEPT D,EMP E 
WHERE D.DEPT_NO = E.DEPT_NO 
高效: 
SELECT DEPT_NO,DEPT_NAME 
FROM DEPT D 
WHERE EXISTS ( SELECT ‘X’ 
FROM EMP E 
WHERE E.DEPT_NO = D.DEPT_NO); 

EXISTS 使查询更为迅速,因为RDBMS核心模块将在子查询的条件一旦满足后,立刻返回结果. 

**7.mmf使用表的别名(Alias) **
当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误. 
(译者注: Column歧义指的是由于SQL中不同的表具有相同的Column名,当SQL语句中出现这个Column时,SQL解析器无法判断这个Column的归属) 

**8.mmf用EXISTS替代IN **
在许多基于基础表的查询中,为了满足一个条件,往往需要对另一个表进行联接.在这种情况下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率. 
低效: 
SELECT * 
FROM EMP (基础表) 
WHERE EMPNO &gt; 0 
AND DEPTNO IN (SELECT DEPTNO 
FROM DEPT 
WHERE LOC = ‘MELB’) 
高效: 

**9.mmf用NOT EXISTS替代NOT IN **
在子查询中,NOT IN子句将执行一个内部的排序和合并. 无论在哪种情况下,NOT IN都是最低效的 (因为它对子查询中的表执行了一个全表遍历). 为了避免使用NOT IN ,我们可以把它改写成外连接(Outer Joins)或NOT EXISTS. 
例如: 
SELECT … 
FROM EMP 
WHERE DEPT_NO NOT IN (SELECT DEPT_NO 
FROM DEPT 
WHERE DEPT_CAT=’A’); 
为了提高效率.改写为: 
(方法一: 高效) 
SELECT …. 
FROM EMP A,DEPT B 
WHERE A.DEPT_NO = B.DEPT(+) 
AND B.DEPT_NO IS NULL 
AND B.DEPT_CAT(+) = ‘A’ 
(方法二: 最高效) 
SELECT …. 
FROM EMP E 
WHERE NOT EXISTS (SELECT ‘X’ 
FROM DEPT D 
WHERE D.DEPT_NO = E.DEPT_NO 
AND DEPT_CAT = ‘A’); 

**10.mmf减少对表的查询 **
在含有子查询的SQL语句中,要特别注意减少对表的查询. 
例如: 
低效 
SELECT TAB_NAME 
FROM TABLES 
WHERE TAB_NAME = ( SELECT TAB_NAME 
FROM TAB_COLUMNS 
WHERE VERSION = 604) 
AND　DB_VER= ( SELECT DB_VER 
FROM TAB_COLUMNS 
WHERE VERSION = 604) 
高效 
SELECT TAB_NAME 
FROM TABLES 
WHERE (TAB_NAME,DB_VER) 
= ( SELECT TAB_NAME,DB_VER) 
FROM TAB_COLUMNS 
WHERE VERSION = 604) 
Update 多个Column 例子: 
低效: 
UPDATE EMP 
SET EMP_CAT = (SELECT MAX(CATEGORY) FROM EMP_CATEGORIES), 
SAL_RANGE = (SELECT MAX(SAL_RANGE) FROM EMP_CATEGORIES) 
WHERE EMP_DEPT = 0020; 
高效: 
UPDATE EMP 
SET (EMP_CAT, SAL_RANGE) 
= (SELECT MAX(...... 
= (SELECT MAX(CATEGORY) , MAX(SAL_RANGE) 
FROM EMP_CATEGORIES) 
WHERE EMP_DEPT = 0020; 

**11\. 在Oracle快速进行数据行存在性检查** 
只检索一个启示就可以判断主键是否能与外键相配，这比Count(*)方法快得多，例如: 
SQL Using Count(*) 
SELECT Count(*) INTO :ll_Count 
FROM ORDER 
WHERE PROD_ID = :ls_CheckProd 
USING SQLCA; 

IF ll_Count &gt; 0 THEN // Cannot delete product 
SQL Using ROWNUM 
SELECT ORDER_ID INTO :ll_OrderID 
FROM ORDER 
WHERE PROD_ID = :ls_CheckProd 
AND ROWNUM &lt; 2 
USING SQLCA; 

IF SQLCA.SQLNRows &lt;&gt; 0 THEN // cannot delete product 

**12　使用%TYPE、%ROWTYPE方式声明变量 **
　　程序设计中常常要通过变量来实现程序间的数据传递，即将表中数据赋值给变量，或是把变量值插入到表中。而要完成这些操作的前提就是，表中数据与变量类型要一致。然而在实际中，表中数据或类型、或宽度有时要变化，一旦变化，就必须去修改程序中的变量声明部分，否则程序将不能正常运行。为了减少这部分程序的修改，编程时使用%TYPE、%ROWTYPE方式声明变量，使变量声明的类型与表中的保持同步，随表的变化而变化，这样的程序在一定程度上具有更强的通用性。 

**13.mmf使用DECODE函数来减少处理时间** 
使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表. 
例如: 
SELECT COUNT(*)，SUM(SAL) 
FROM　EMP 
WHERE DEPT_NO = 0020 
AND ENAME LIKE　‘SMITH%’; 

SELECT COUNT(*)，SUM(SAL) 
FROM　EMP 
WHERE DEPT_NO = 0030 
AND ENAME LIKE　‘SMITH%’; 

你可以用DECODE函数高效地得到相同结果 

SELECT COUNT(DECODE(DEPT_NO,0020,’X’,NULL)) D0020_COUNT, 
COUNT(DECODE(DEPT_NO,0030,’X’,NULL)) D0030_COUNT, 
SUM(DECODE(DEPT_NO,0020,SAL,NULL)) D0020_SAL, 
SUM(DECODE(DEPT_NO,0030,SAL,NULL)) D0030_SAL 
FROM EMP WHERE ENAME LIKE ‘SMITH%’; 

类似的,DECODE函数也可以运用于GROUP BY 和ORDER BY子句中. 

**14.mmf尽量多使用COMMIT **
只要有可能,在程序中尽量多使用COMMIT, 这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少: 
COMMIT所释放的资源: 
a.mmf回滚段上用于恢复数据的信息. 
b.mmf被程序语句获得的锁 
c.mmfredo log buffer 中的空间 
d.mmfORACLE为管理上述3种资源中的内部花费 
15.mmf整合简单,无关联的数据库访问 
如果你有几个简单的数据库查询语句,你可以把它们整合到一个查询中(即使它们之间没有关系) 
例如: 

SELECT NAME 
FROM EMP 
WHERE EMP_NO = 1234; 

SELECT NAME 
FROM DPT 
WHERE DPT_NO = 10 ; 

SELECT NAME 
FROM CAT 
WHERE CAT_TYPE = ‘RD’; 

上面的3个查询可以被合并成一个: 

SELECT E.NAME , D.NAME , C.NAME 
FROM CAT C , DPT D , EMP E,DUAL X 
WHERE NVL(‘X’,X.DUMMY) = NVL(‘X’,E.ROWID(+)) 
AND NVL(‘X’,X.DUMMY) = NVL(‘X’,D.ROWID(+)) 
AND NVL(‘X’,X.DUMMY) = NVL(‘X’,C.ROWID(+)) 
AND E.EMP_NO(+) = 1234 
AND D.DEPT_NO(+) = 10 
AND C.CAT_TYPE(+) = ‘RD’